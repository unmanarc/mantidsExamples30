#include "api_endpoints.h"
#include <Mantids30/Memory/a_allvars.h>
#include <Mantids30/Protocol_HTTP/api_return.h>

#include "app_context.h"

using namespace Mantids30;
using namespace Mantids30::Program;
using namespace Mantids30::Memory;
using namespace Mantids30::Network::Servers;
using namespace Mantids30::Network::Protocols;

// LLM CONTEXT FOR BUILDING LIBMANTIDS3 APP's

/*
struct ClientDetails {
std::string ipAddress, extraData,tlsCommonName,userAgent;
};
struct RequestParameters
{
Json::Value emptyJSON;
Json::Value *inputJSON = &emptyJSON; ///< Holds the input JSON that came from the request body.
DataFormat::JWT::Token emptyToken; ///< Holds a default empty token
DataFormat::JWT::Token *jwtToken = &emptyToken; ///< Holds JWT token data, if present and validated the pointer will be changed.
};
enum eLogLevels {LEVEL_INFO,LEVEL_WARN,LEVEL_CRITICAL,LEVEL_ERR,LEVEL_DEBUG,LEVEL_DEBUG1,LEVEL_SECURITY_ALERT};
class Token {
public:
std::string getIssuer() const;
std::string getImpersonator() const;
std::string getSubject() const; //< here is the username!
std::string getDomain() const;
std::string getAudience() const;
std::string getJwtId() const;
std::map<std::string,Json::Value> getAllClaims();
Json::Value getAllClaimsAsJSON();
bool isAdmin() const;
Json::Value getClaim(const std::string &name) const;
bool hasClaim(const std::string &name) const;
Json::Value *getClaimsPTR();
};
class AppLog : public LogBase
{
public:
void log(const std::string & module, const std::string & user, const std::string & ip, eLogLevels logSeverity, const uint32_t &outSize, const char* fmtLog,  ...);
void log2(const std::string & module, const std::string & user, const std::string & ip, eLogLevels logSeverity, const char* fmtLog,  ...);
void log1(const std::string & module, const std::string & ip, eLogLevels logSeverity, const char* fmtLog,  ...);
void log0(const std::string & module, eLogLevels logSeverity, const char* fmtLog,  ...);
};

bool addEndpoint(const MethodMode &mode, const std::string &resourceName, MethodType method, void *context, const uint32_t &SecurityOptions, const std::set<std::string> requiredScopes);
*/

API::APIReturn apiEcho(void *,const API::RESTful::RequestParameters &params, Sessions::ClientDetails &)
{
    Json::Value jsonResponse;

    jsonResponse["echo"] = JSON_ASSTRING(*params.inputJSON,"message","");
    jsonResponse["status"] = "success";

    return jsonResponse;
}

API::APIReturn exampleFunctionRD(void *, const API::RESTful::RequestParameters &params, Sessions::ClientDetails &clientDetails)
{
    // All Read-only operations in the database should use the Lock_RD (Read) instead the Lock_RW (Read-Write). 
    // Don't worry about the cursor because QueryInstance have his own timed mutex.
    Threads::Sync::Lock_RD lock(g_ctx.dbShrLock);

    std::string appName = JSON_ASSTRING(*params.inputJSON, "appName", "");
    Abstract::STRING roleId, description;
    std::string user = params.jwtToken->getSubject();

    if (appName.empty())
    {
        return API::APIReturn(HTTP::Status::S_400_BAD_REQUEST, "invalid_request", "Application name is required");
    }

    APP_LOG->log2(__func__, user, clientDetails.ipAddress, Logs::LEVEL_INFO, "User is consulting myTable for app %s", appName.c_str());

    {
        // Every Query instance should be called between curly braces, QueryInstance have an internal mutex that is freed when destroyed.
        // You MUST not call any other query while QueryInstance exist (it may modify the curson in the database and have undefined behaviour)
        SQLConnector::QueryInstance i = g_ctx.dbConnector->qSelect("SELECT `roleId`,`roleDescription` FROM myTable WHERE `f_appName`=:appName;", 
                {{":appName", MAKE_VAR(STRING, appName)}},{&roleId, &description});

        // This is the only way to iterate. don't assume there are other ways like getting result by column position.
        Json::Value jsonResponse = Json::arrayValue;
        while (i.getResultsOK() && i.query->step())
        {
            Json::Value x;
            x["description"] = description.getValue();
            x["id"] = roleId.getValue();
            jsonResponse.append(x);
        }
    }

    return jsonResponse;
}

API::APIReturn exampleFunctionRW(void *, const API::RESTful::RequestParameters &params, Sessions::ClientDetails &clientDetails)
{
    // But when a write operation is done, Lock_RW (Read-Write) is mandatory.
    // This is important if you use multiple execute's in the database, because you may want to avoid a "mix" of executions/reads
    Threads::Sync::Lock_RW lock(g_ctx.dbShrLock);

    std::string appName = JSON_ASSTRING(*params.inputJSON, "appName", "");
    uint32_t activityId = JSON_ASUINT(*params.inputJSON, "activityId", 0);
    std::string activityDescription = JSON_ASSTRING(*params.inputJSON, "activityDescription", "");

    if (appName.empty())
    {
        return API::APIReturn(HTTP::Status::S_400_BAD_REQUEST, "invalid_request", "Application name is required");
    }

    // You should always check the output of execute and check if it's true...
    // Also, BEGIN/ROLLBACK/COMMIT is NOT tested/supported yet.
    // Database won't be throwing errors (try/catch)... No need to use try/catch
    if (!g_ctx.dbConnector->execute("INSERT INTO iam.applicationActivities (f_appName, activityId, parentActivity, description) VALUES (:appName, :activityId, NULL, :description);",
                                    {{":appName", MAKE_VAR(STRING, appName)}, {":activityId", MAKE_VAR(UINT32, activityId)}, {":description", MAKE_VAR(STRING, activityDescription)}}))
    {
        return API::APIReturn(HTTP::Status::S_500_INTERNAL_SERVER_ERROR, "internal_error", "DB Failed");
    }

    return API::APIReturn();
}

auto registerAPIEndpoints() -> std::shared_ptr<API::RESTful::Endpoints>
{
    auto endpoints = std::make_shared<API::RESTful::Endpoints>();

    using M = API::RESTful::Endpoints;
    using Sec = M::SecurityOptions;

    // Public REST API endpoints (no authentication required):
    endpoints->addEndpoint(M::POST, "echo",  Sec::NO_AUTH, {},nullptr, &apiEcho);
    // Public REST API endpoints (authentication cookie is requiered here):
    endpoints->addEndpoint(M::GET, "exampleFunctionRD", Sec::REQUIRE_JWT_COOKIE_AUTH, {"APP_READ"}, nullptr, &exampleFunctionRD);
    endpoints->addEndpoint(M::POST, "exampleFunctionRW", Sec::REQUIRE_JWT_COOKIE_AUTH, {"APP_WRITE"}, nullptr, &exampleFunctionRW);

    // APP_READ/APP_WRITE are the requiered application scopes for each function, you should adapt and create your own ones.

    return endpoints;
}
